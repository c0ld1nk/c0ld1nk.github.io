<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>遥乡书屋</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on 遥乡书屋</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 30 May 2025 10:51:07 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Wp</title>
      <link>http://localhost:1313/docs/htb/sherlock/wp/</link>
      <pubDate>Fri, 30 May 2025 10:51:07 +0800</pubDate>
      <guid>http://localhost:1313/docs/htb/sherlock/wp/</guid>
      <description>&lt;p&gt;解压密码为hacktheblue&lt;/p&gt;&#xA;&lt;h1 id=&#34;brutus&#34;&gt;Brutus &lt;a href=&#34;#brutus&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h1&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;在这个非常简单的 Sherlock 任务中，您将熟悉 Unix 系统的 auth.log 和 wtmp 日志。我们将探讨一个 Confluence 服务器通过 SSH 服务遭受暴力破解的场景。攻击者获取服务器访问权限后，还进行了其他活动，这些都可以通过 auth.log 追踪。尽管 auth.log 主要用于暴力破解分析，但在本次调查中，我们将深入挖掘这一日志的全部潜力，包括权限提升、持久化攻击的迹象，甚至部分命令执行的可见性。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;task1&#34;&gt;Task1 &lt;a href=&#34;#task1&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;分析 auth.log 日志。攻击者用于实施暴力破解攻击的 IP 地址是什么？&#xA;65.2.161.68&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/Pasted%20image%2020250423141308_953566843010051555.png&#34; alt=&#34;&#34; width=&#34;720&#34; height=&#34;121&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;h2 id=&#34;task2&#34;&gt;Task2 &lt;a href=&#34;#task2&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;识别攻击者手动登录服务器以执行其目标的时间戳。登录时间将与认证时间不同，可在 wtmp 记录中找到。&#xA;root&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/Pasted%20image%2020250423141749_15408015874367616132.png&#34; alt=&#34;&#34; width=&#34;937&#34; height=&#34;105&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;h2 id=&#34;task3&#34;&gt;Task3 &lt;a href=&#34;#task3&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;识别攻击者手动登录服务器以执行其目标的时间戳。登录时间将与认证时间不同，可在 wtmp 记录中找到。&#xA;2024-03-06 06:32:45&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;分析wtmp文件即可&lt;/p&gt;&#xA;&lt;h2 id=&#34;task4&#34;&gt;Task4 &lt;a href=&#34;#task4&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;SSH 登录会话在登录时会被跟踪并分配一个会话编号。攻击者针对问题 2 中用户账户的会话被分配了哪个会话编号？&#xA;37&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/Pasted%20image%2020250423141749_15408015874367616132.png&#34; alt=&#34;&#34; width=&#34;937&#34; height=&#34;105&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;h2 id=&#34;task5&#34;&gt;Task5 &lt;a href=&#34;#task5&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;攻击者在服务器上添加了一个新用户作为其持久化策略的一部分，并赋予该新用户账户更高的权限。这个账户的名称是什么？&#xA;cyberjunkie&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/Pasted%20image%2020250423143634_8122255457488324670.png&#34; alt=&#34;&#34; width=&#34;797&#34; height=&#34;76&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;h2 id=&#34;task6&#34;&gt;Task6 &lt;a href=&#34;#task6&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;用于通过创建新账户实现持久化的 MITRE ATT&amp;amp;CK 子技术 ID 是什么？&#xA;T1136.001&lt;/p&gt;</description>
    </item>
    <item>
      <title>RCE</title>
      <link>http://localhost:1313/docs/ctf/%E7%9F%A5%E8%AF%86%E7%82%B9/rce/</link>
      <pubDate>Fri, 30 May 2025 10:12:11 +0800</pubDate>
      <guid>http://localhost:1313/docs/ctf/%E7%9F%A5%E8%AF%86%E7%82%B9/rce/</guid>
      <description>&lt;h1 id=&#34;php&#34;&gt;PHP &lt;a href=&#34;#php&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&#34;基本函数&#34;&gt;基本函数 &lt;a href=&#34;#%e5%9f%ba%e6%9c%ac%e5%87%bd%e6%95%b0&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;1.&lt;code&gt;eval()&lt;/code&gt;可以将传入的字符串当作php代码执行&#xA;解题时常用的指令：&lt;code&gt;phpinfo()&lt;/code&gt;查看是否有回显&#xA;system()指令用于执行系统命令，如&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;58ae8ef&#34; class=&#34;language-php &#34;&gt;&#xA;  &lt;code&gt;system(&amp;#39;ls&amp;#39;);&#xA;system(&amp;#39;cat&amp;#39;);&#xA;//记得在每一条指令后面加；&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;其它函数：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;970f1de&#34; class=&#34;language-php &#34;&gt;&#xA;  &lt;code&gt;//具体函数内容查看手册&#xA;exec&#xA;shell_exec&#xA;passthru&#xA;popen&#xA;proc_popen&#xA;Assert(mixed $assertion,string $description = ?)&#xA;//会检查assertion，如果是字符串，会被当成php代码执行&#xA;Call_user_func(callable $callback …..)&#xA;//callback是被调用的回调函数&#xA;Call_user_func_array(callable $callback)&#xA;//同上&#xA;Creat_function(args,code)&#xA;//如&#xA;&amp;lt;?php&#xA;error_reporting(0);&#xA;$new_func = create_function(&amp;#39;$a,$b&amp;#39;,&amp;#39;return &amp;#34;$a  &amp;#34;.&amp;#34;$b&amp;#34;;&amp;#39;);//new_func为函数名，$a $b为参数，后面代码&#xA;echo $new_func(&amp;#39;hello&amp;#39;,&amp;#39;hack&amp;#39;).&amp;#34;\n&amp;#34;;&#xA;?&amp;gt;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;连接两个命令&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;2c5b2cc&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;|&#xA;||&#xA;&amp;amp;&#xA;&amp;amp;&amp;amp;&#xA;;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;h2 id=&#34;绕过&#34;&gt;绕过 &lt;a href=&#34;#%e7%bb%95%e8%bf%87&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;简单绕过关键词过滤&lt;code&gt;a=eval($_GET[&#39;A&#39;])&amp;amp;A=system&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;内联执行：cat `ls`，echo $(ls)&lt;/li&gt;&#xA;&lt;li&gt;使用&amp;rsquo;&amp;lsquo;包裹一组指令 &lt;code&gt;(&#39;ls /&#39;)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;绕过内置过滤函数&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;d8357b2&#34; class=&#34;language-php &#34;&gt;&#xA;  &lt;code&gt;$url=escapeshellarg($url);&#xA;&#xA;$url=escapeshellcmd($url);&#xA;/*&#xA;连用会产生单引号逃逸，传入1&amp;#39; xxx&#xA;返回&amp;#39;1&amp;#39;\\&amp;#39;&amp;#39;XXX\&amp;#39;&#xA;\被转义，还多出来一个&amp;#39;&#xA;*/&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;绕过文件名限制&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pickle反序列化</title>
      <link>http://localhost:1313/docs/ctf/%E7%9F%A5%E8%AF%86%E7%82%B9/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Fri, 30 May 2025 09:41:09 +0800</pubDate>
      <guid>http://localhost:1313/docs/ctf/%E7%9F%A5%E8%AF%86%E7%82%B9/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>&lt;h1 id=&#34;可被序列化的目标&#34;&gt;可被序列化的目标： &lt;a href=&#34;#%e5%8f%af%e8%a2%ab%e5%ba%8f%e5%88%97%e5%8c%96%e7%9a%84%e7%9b%ae%e6%a0%87&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h1&gt;&lt;ul&gt;&#xA;&lt;li&gt;None，True，False&lt;/li&gt;&#xA;&lt;li&gt;整数，浮点数，复数&lt;/li&gt;&#xA;&lt;li&gt;str，byte，bytearray&lt;/li&gt;&#xA;&lt;li&gt;只包含可序列化对象的集合：tuple，list，set，dict&lt;/li&gt;&#xA;&lt;li&gt;定义在模块最外层的函数，指使用def定义的函数，而不是lambda&lt;/li&gt;&#xA;&lt;li&gt;定义在模块最外层的内置函数&lt;/li&gt;&#xA;&lt;li&gt;定义在模块最外层的类&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;__dict__&lt;/code&gt; 属性值或者&lt;code&gt;__getstate__()&lt;/code&gt;函数返回值可以被序列化的类&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;反序列化过程&#34;&gt;反序列化过程 &lt;a href=&#34;#%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e8%bf%87%e7%a8%8b&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;pickle反序列化依靠PVM（Pickle Virtual Machine）进行。&#xA;其涉及三个部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解析引擎&lt;/li&gt;&#xA;&lt;li&gt;存放到栈&lt;/li&gt;&#xA;&lt;li&gt;存储到内存&#xA;解析引擎：从流中读取opcode和参数，对其进行解释处理，直到遇到&lt;code&gt;.&lt;/code&gt;停止，最后留在栈顶的值就是反序列化对象。&#xA;栈：由list实现，存储临时对象，参数以及对象&#xA;内存memo：由dict实现，为PVM的生命周期提供存储，即将反序列化完成的数据以&lt;code&gt;key-value&lt;/code&gt;的形式存在memo中以供后面使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;opcode&#34;&gt;opcode &lt;a href=&#34;#opcode&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;pickle在由不同的实现版本，在py2和3得到的opcode不相同，但各个版本可以向下兼容。目前有六个版本：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;b9bb5dd&#34; class=&#34;language-python &#34;&gt;&#xA;  &lt;code&gt;import pickle&#xA;&#xA;a={&amp;#39;1&amp;#39;: 1, &amp;#39;2&amp;#39;: 2}&#xA;&#xA;print(f&amp;#39;# 原变量：{a!r}&amp;#39;)&#xA;for i in range(4):&#xA;    print(f&amp;#39;pickle版本{i}&amp;#39;,pickle.dumps(a,protocol=i))&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;2e26bc1&#34; class=&#34;language-text &#34;&gt;&#xA;  &lt;code&gt;# 原变量：{&amp;#39;1&amp;#39;: 1, &amp;#39;2&amp;#39;: 2}&#xA;pickle版本0 b&amp;#39;(dp0\nV1\np1\nI1\nsV2\np2\nI2\ns.&amp;#39;&#xA;pickle版本1 b&amp;#39;}q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&amp;#39;&#xA;pickle版本2 b&amp;#39;\x80\x02}q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&amp;#39;&#xA;pickle版本3 b&amp;#39;\x80\x03}q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&amp;#39;&#xA;pickle版本4 b&amp;#39;\x80\x04\x95\x11\x00\x00\x00\x00\x00\x00\x00}\x94(\x8c\x011\x94K\x01\x8c\x012\x94K\x02u.&amp;#39;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;pickle3版本opcode示例：&#xA;原数据：&lt;code&gt;abcd&lt;/code&gt;&#xA;&lt;code&gt;b&#39;\x80\x03X\x04\x00\x00\x00abcdq\x00.&#39;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;\x80&lt;/code&gt;：协议头声明，读取此字符串后，会再读取一个字节&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;\x03&lt;/code&gt;：协议版本&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;\x04\x00\x00\x00&lt;/code&gt;：数据长度：4&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;abcd&lt;/code&gt;数据&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;q&lt;/code&gt;存储在栈顶的字符串长度&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;\x00&lt;/code&gt;栈顶位置，一个字节&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;.&lt;/code&gt;数据截止&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;b&#39;\x80\x03c__main__\nStudent\n)\x81}(Vname\nVrxz\nVgrade\nVG2\nub.&#39;&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>NodeJs</title>
      <link>http://localhost:1313/docs/ctf/%E7%9F%A5%E8%AF%86%E7%82%B9/nodejs/</link>
      <pubDate>Thu, 29 May 2025 16:38:45 +0800</pubDate>
      <guid>http://localhost:1313/docs/ctf/%E7%9F%A5%E8%AF%86%E7%82%B9/nodejs/</guid>
      <description>&lt;h1 id=&#34;命令执行&#34;&gt;命令执行 &lt;a href=&#34;#%e5%91%bd%e4%bb%a4%e6%89%a7%e8%a1%8c&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h1&gt;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;298affe&#34; class=&#34;language-js &#34;&gt;&#xA;  &lt;code&gt;require(&amp;#39;child_process&amp;#39;).exec(&amp;#39;ls&amp;#39;); //返回值是child_process，不能转字符串&#xA;require(&amp;#39;child_process&amp;#39;).execSync(&amp;#39;ls&amp;#39;).toString(); //返回值是字符串&#xA;require(&amp;#39;child_process&amp;#39;).spawnSync(&amp;#39;ls&amp;#39;).stdout.toString();// 返回object，toString转成字符串&#xA;//绕过简单的限制&#xA;require(&amp;#39;child_process&amp;#39;)[&amp;#39;exe&amp;#39;&amp;#43;&amp;#39;cSync&amp;#39;](&amp;#39;ls&amp;#39;).toString()&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;不用&lt;code&gt;child_process&lt;/code&gt;读取文件&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;b75ef0f&#34; class=&#34;language-js &#34;&gt;&#xA;  &lt;code&gt;__filename //获取当前文件的绝对路径&#xA;__dirname //获取当前文件解析过后的文件夹的绝对路径&#xA;require(&amp;#39;fs&amp;#39;).readFileSync(__filename,&amp;#39;utf-8&amp;#39;); //读取当前文件&#xA;require(&amp;#39;fs&amp;#39;).readdirSync(&amp;#39;.&amp;#39;) //读取当前目录下所有文件&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;h1 id=&#34;md5&#34;&gt;md5 &lt;a href=&#34;#md5&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h1&gt;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;6111101&#34; class=&#34;language-js &#34;&gt;&#xA;  &lt;code&gt;if(a &amp;amp;&amp;amp; b &amp;amp;&amp;amp; a.length===b.length &amp;amp;&amp;amp; a!==b &amp;amp;&amp;amp; md5(a&amp;#43;flag)===md5(b&amp;#43;flag))&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;传入a[]=1&amp;amp;b[]=2&#xA;得到的是[&amp;lsquo;1&amp;rsquo;]和[&amp;lsquo;2&amp;rsquo;]&#xA;而nodejs中数组和字符串的拼接如下：&lt;/p&gt;&lt;/blockquote&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;a825148&#34; class=&#34;language-js &#34;&gt;&#xA;  &lt;code&gt;console.log(5&amp;#43;[6,6]); //56,6&#xA;console.log(&amp;#34;5&amp;#34;&amp;#43;6); //56&#xA;console.log(&amp;#34;5&amp;#34;&amp;#43;[6,6]); //56,6&#xA;console.log(&amp;#34;5&amp;#34;&amp;#43;[&amp;#34;6&amp;#34;,&amp;#34;6&amp;#34;]); //56,6&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;则[&amp;lsquo;a&amp;rsquo;]+flag== &amp;lsquo;a&amp;rsquo;+flag&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;如果传入的是非数字索引，比如&lt;code&gt;[x]=1&lt;/code&gt;，那么就会变为js的对象&lt;code&gt;{x:&#39;1&#39;}&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;0138822&#34; class=&#34;language-js &#34;&gt;&#xA;  &lt;code&gt;let a={&#xA;    x:&amp;#39;1&amp;#39;&#xA;}&#xA;console.log(a&amp;#43;&amp;#34;flag{123}&amp;#34;)&#xA;//返回的是： [object Object]flag{123}&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;所以传入a[x]=1&amp;amp;b[x]=1也能绕过，此时&lt;code&gt;a!==b&lt;/code&gt;比较的是内存地址，而不是键值。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;原型链污染&#34;&gt;原型链污染 &lt;a href=&#34;#%e5%8e%9f%e5%9e%8b%e9%93%be%e6%b1%a1%e6%9f%93&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h1&gt;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;7faf206&#34; class=&#34;language-js &#34;&gt;&#xA;  &lt;code&gt;//定义一个类&#xA;function Foo() {&#xA;    this.bar = 1&#xA;}&#xA;&#xA;new Foo()&#xA;&#xA;//类内的方法&#xA;function Foo() {&#xA;    this.bar = 1&#xA;    this.show = function() {&#xA;        console.log(this.bar)&#xA;        this.bar=this.bar&amp;#43;1&#xA;    }&#xA;}&#xA;&#xA;(new Foo()).show() //输出1&#xA;//但是每次新建一个foo对象，this.show就会执行一次，show方法是绑定在对象上的，而不是绑定在类上&#xA;//使用原型prototype创建类时，就会只创建一次show方法。&#xA;function Foo() {&#xA;    this.bar = 1&#xA;}&#xA;&#xA;Foo.prototype.show = function show() {&#xA;    console.log(this.bar)&#xA;}&#xA;&#xA;let foo = new Foo()&#xA;foo.show() //输出1&#xA;//原型prototype是类Foo的一个属性，所有实例化的对象，都有这个熟悉的内容。&#xA;//foo对象天生就有show方法&#xA;//通过proto属性可以访问类的原型，即：&#xA;foo.__proto__==Foo.prototype&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;总结：&#xA;&lt;code&gt;prototype&lt;/code&gt;是一个类的属性，所有类对象实例化时都会有&lt;code&gt;prototype&lt;/code&gt;中的属性和方法&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
